<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Number System Converter (with Exact Fraction Steps)</title>
<style>
  :root{
    --bg:#f2f2f2; --card:#ffffff; --accent:#34a853;
    --muted:#666; --panel:#eef0ff; --code:#e3e3e3;
    --border:#d6d6d6; --errbg:#ffe8e8; --errbd:#ffb4b4; --err:#a40000;
  }
  body{font-family:system-ui,Arial,sans-serif;background:var(--bg);margin:0;padding:24px}
  .card{max-width:860px;margin:auto;background:var(--card);padding:28px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.08)}
  h1,h2,h3,h4,p{margin:0}
  label{font-weight:700;margin-top:14px;display:block}
  select,input,button{width:100%;padding:12px;border-radius:8px;border:1px solid var(--border);font-size:16px}
  button{background:var(--accent);color:#fff;border:none;margin-top:12px}
  button:hover{filter:brightness(.95);cursor:pointer}
  .output{background:var(--panel);border-radius:10px;padding:16px;margin-top:18px}
  .title{font-weight:800;margin:0 0 6px}
  pre{background:var(--code);border-radius:8px;padding:12px;white-space:pre-wrap}
  .error{background:var(--errbg);border:1px solid var(--errbd);color:var(--err);padding:10px;border-radius:8px;margin-top:10px;display:none}
  .muted{color:var(--muted)}
  hr{margin:10px 0;border:none;border-top:1px solid #ccc}
  .header{text-align:center; line-height:1.6; margin-bottom:20px}
  .header h2{font-size:24px; font-weight:700}
  .header h3{font-size:20px; font-weight:500}
  .header h4{font-size:18px; font-weight:500}
  .header .designer{margin:5px 0; font-size:14px}
  .header .title{font-size:18px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; letter-spacing: .5px}
</style>
</head>
<body>
  <div class="card">

    <!-- Header -->
    <div class="header">
      <h2>Northern Technical University</h2>
      <h3>Technical Engineering College - Mosul </h3>
      <h4>Chemical and Petroleum Industries Technologies Engineering</h4>
      <p class="designer"><strong>Designed by: Azam Isam and Hiba Abdulkareem</strong></p>
      <hr>
      <h3 class="title">Number System Converter</h3>
    </div>

    <label for="conversion">Select Conversion Type:</label>
    <select id="conversion">
      <option value="decToBin">Decimal → Binary</option>
      <option value="binToDec">Binary → Decimal</option>
      <option value="decToOct">Decimal → Octal</option>
      <option value="octToDec">Octal → Decimal</option>
      <option value="decToHex">Decimal → Hexadecimal</option>
      <option value="hexToDec">Hexadecimal → Decimal</option>
      <option value="binToOct">Binary → Octal</option>
      <option value="octToBin">Octal → Binary</option>
      <option value="binToHex">Binary → Hexadecimal</option>
      <option value="hexToBin">Hexadecimal → Binary</option>
      <option value="octToHex">Octal → Hexadecimal</option>
      <option value="hexToOct">Hexadecimal → Octal</option>
    </select>

    <label for="inputNumber">Enter Number:</label>
    <input id="inputNumber" placeholder="e.g., 40 or 1011 or 2F or 12.5 or 1101.01 or A.F" />

    <button id="convertBtn">Convert</button>

    <div id="error" class="error"></div>

    <div class="output">
      <p class="title">Result:</p>
      <p id="result" class="muted mono">—</p>
      <p class="title">Steps:</p>
      <pre id="steps" class="muted mono">—</pre>
      <p class="title">Rule:</p>
      <p id="rule" class="muted">—</p>
    </div>
  </div>

<script>
/* ===== CONFIG ===== */
const MAX_FRAC_DIGITS = 20;
const LINE = (label) => `\n──────── ${label} ────────\n`;

/* ===== RULES TEXT ===== */
const rules = {
  decToBin: "Integer: divide by 2 and collect remainders. Fraction: multiply by 2; take the integer part each time (carry).",
  binToDec: "Integer: sum d×2^n. Fraction: sum d×2^-n.",
  decToOct: "Integer: divide by 8 with remainders. Fraction: multiply by 8; take the integer part.",
  octToDec: "Integer: sum d×8^n. Fraction: sum d×8^-n.",
  decToHex: "Integer: divide by 16 with remainders. Fraction: multiply by 16; take the integer part (0–F).",
  hexToDec: "Integer: sum d×16^n. Fraction: sum d×16^-n.",
  binToOct: "Bridge: group bits in 3s (pad).",
  octToBin: "Bridge: each octal digit → 3 bits.",
  binToHex: "Bridge: group bits in 4s (pad).",
  hexToBin: "Bridge: each hex digit → 4 bits.",
  octToHex: "Via binary: oct→bin→hex.",
  hexToOct: "Via binary: hex→bin→oct."
};

/* ===== DOM HELPERS ===== */
const el = (id)=>document.getElementById(id);
const show = (id, txt)=>{ el(id).textContent = txt; el(id).classList.remove('muted'); };
const clearOutputs = ()=>{ show("result","—"); show("steps","—"); show("rule","—"); el("error").style.display="none"; };

/* ===== VALIDATION ===== */
const isValid = {
  dec: s => /^\d+(\.\d+)?$/.test(s),
  bin: s => /^[01]+(\.[01]+)?$/.test(s),
  oct: s => /^[0-7]+(\.[0-7]+)?$/.test(s),
  hex: s => /^[0-9a-fA-F]+(\.[0-9a-fA-F]+)?$/.test(s),
};
const expected = {
  decToBin: "dec", decToOct: "dec", decToHex: "dec",
  binToDec: "bin", binToOct: "bin", binToHex: "bin",
  octToDec: "oct", octToBin: "oct", octToHex: "oct",
  hexToDec: "hex", hexToBin: "hex", hexToOct: "hex"
};

/* ===== STRING/PADDING UTILITIES ===== */
function splitParts(s){
  const [i,f=""] = s.split(".");
  return { i, f, hasFrac: s.includes(".") && f.length>0 };
}
function groupLeft(str, size){
  if(!str) return "";
  const out = [];
  for(let i=0;i<str.length;i+=size){ out.push(str.slice(i,i+size)); }
  return out.join(" ");
}
function padLeftTo(str, size){
  return str.padStart(Math.ceil(str.length/size)*size,"0");
}
function padRightTo(str, size){
  if(!str) return "";
  const len = Math.ceil(str.length/size)*size;
  return str.padEnd(len,"0");
}
function trimFracZeros(out){
  if(!out.includes(".")) return out;
  out = out.replace(/\.?0+$/,"");
  return out;
}

/* ===== EXACT DECIMAL STRING FOR BigInt RATIONALS ===== */
/* Render p/q as a clean decimal string (no FP). places caps digits after decimal. */
function rationalToDecimal(p, q, places=30){
  // p, q are BigInt; q>0
  let sign = "";
  if (p < 0n) { sign = "-"; p = -p; }
  const int = p / q;
  let rem = p % q;

  if (rem === 0n) return sign + int.toString();

  let digits = "";
  for (let i=0; i<places && rem>0n; i++){
    rem *= 10n;
    const d = rem / q;
    rem = rem % q;
    digits += d.toString();
  }
  // trim trailing zeros
  digits = digits.replace(/0+$/,"");
  return digits.length ? `${sign}${int.toString()}.${digits}` : sign + int.toString();
}

/* ===== DECIMAL <-> BASE b WITH FRACTIONS (exact carry method) ===== */
function decToBase(raw, base, alphabet="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"){
  let steps = "";
  const {i, f, hasFrac} = splitParts(raw);

  // Integer part via BigInt divisions
  steps += LINE("Integer part");
  let n = BigInt(i||"0");
  if(n===0n){ steps += "0 → 0\n"; }
  let intOut = "";
  while(n > 0n){
    const q = n / BigInt(base), r = Number(n % BigInt(base));
    const dig = alphabet[r];
    steps += `${n} ÷ ${base} = ${q} remainder ${dig}\n`;
    intOut = dig + intOut; n = q;
  }
  if(intOut==="") intOut="0";

  // Fractional part using multiply-and-carry with exact decimals in the log
  let fracOut = "";
  if(hasFrac){
    steps += LINE("Fractional part");
    // 0.f  →  num/den with den = 10^len(f)
    let num = BigInt(f);
    const den = 10n ** BigInt(f.length);

    for(let k=1; k<=MAX_FRAC_DIGITS && num>0n; k++){
      const xNum = num * BigInt(base);  // (num/den) * base = xNum / den
      const carry = xNum / den;         // integer part
      const dig = alphabet[Number(carry)];
      const prodDec = rationalToDecimal(xNum, den, 30);
      const curDec  = rationalToDecimal(num, den, 30);

      steps += `(${k}) ${curDec} × ${base} = ${prodDec} → digit ${dig}\n`;

      fracOut += dig;
      num = xNum % den;                 // keep remainder for next step
    }
    if(num>0n) steps += `… continue until desired digits or remainder becomes 0.\n`;
  }

  const result = trimFracZeros(fracOut ? `${intOut}.${fracOut}` : intOut);
  return { result, steps };
}

function baseToDec(raw, base){
  const {i, f, hasFrac} = splitParts(raw.toUpperCase());
  const val = c => parseInt(c, base);
  let steps = "";

  steps += LINE("Integer part");
  let intSum = 0;
  i.split("").reverse().forEach((d, idx)=>{
    const v = val(d)*(base**idx);
    steps += `${d} × ${base}^${idx} = ${v}\n`;
    intSum += v;
  });

  let fracSum = 0;
  if(hasFrac){
    steps += LINE("Fractional part");
    f.split("").forEach((d, idx)=>{
      const p = idx+1;
      const v = val(d)*(base**(-p));
      steps += `${d} × ${base}^-${p} = ${v}\n`;
      fracSum += v;
    });
  }

  const sum = intSum + fracSum;
  steps += `\nSum = ${sum}`;
  return { result: String(sum), steps };
}

/* ===== BRIDGES (support fractions) ===== */
function octDigitToBin(d){ return parseInt(d,8).toString(2).padStart(3,"0"); }
function hexDigitToBin(d){ return parseInt(d,16).toString(2).padStart(4,"0"); }

function octToBinWithFrac(raw){
  const {i,f,hasFrac} = splitParts(raw);
  let steps = LINE("Integer part") + "Replace each octal digit with 3-bit binary:\n";
  let intBin = i.split("").map(d=>{
    const b = octDigitToBin(d); steps += `${d} → ${b}\n`; return b;
  }).join("") || "000";

  let fracBin = "";
  if(hasFrac){
    steps += LINE("Fractional part");
    f.split("").forEach(d=>{
      const b = octDigitToBin(d); steps += `${d} → ${b}\n`; fracBin += b;
    });
  }
  steps += `\nInteger (3-bit groups): ${groupLeft(intBin,3)}`;
  if(hasFrac) steps += `\nFraction (3-bit groups): ${groupLeft(fracBin,3)}`;
  const result = fracBin ? `${intBin}.${fracBin}` : intBin;
  return {bin: result, steps};
}

function hexToBinWithFrac(raw){
  const {i,f,hasFrac} = splitParts(raw.toUpperCase());
  let steps = LINE("Integer part") + "Replace each hex digit with 4-bit binary:\n";
  let intBin = i.split("").map(d=>{
    const b = hexDigitToBin(d); steps += `${d} → ${b}\n`; return b;
  }).join("") || "0000";

  let fracBin = "";
  if(hasFrac){
    steps += LINE("Fractional part");
    f.split("").forEach(d=>{
      const b = hexDigitToBin(d); steps += `${d} → ${b}\n`; fracBin += b;
    });
  }
  steps += `\nInteger (4-bit groups): ${groupLeft(intBin,4)}`;
  if(hasFrac) steps += `\nFraction (4-bit groups): ${groupLeft(fracBin,4)}`;
  const result = fracBin ? `${intBin}.${fracBin}` : intBin;
  return {bin: result, steps};
}

function binToOctWithFrac(raw){
  const {i,f,hasFrac} = splitParts(raw);
  const intPad = padLeftTo(i,3);
  const fracPad = hasFrac ? padRightTo(f,3) : "";
  let steps = LINE("Integer part");
  steps += `Pad to multiple of 3: ${intPad}\nGroup (left): ${(intPad.match(/\d{3}/g)||[]).join(" ")}\n`;
  if(hasFrac){
    steps += LINE("Fractional part");
    steps += `Pad to multiple of 3: ${fracPad}\nGroup (right): ${(fracPad.match(/\d{3}/g)||[]).join(" ")}\n`;
  }
  const intOct = (intPad.match(/\d{3}/g)||[]).map(c=>parseInt(c,2).toString(8)).join("") || "0";
  const fracOct = hasFrac ? (fracPad.match(/\d{3}/g)||[]).map(c=>parseInt(c,2).toString(8)).join("") : "";
  const out = fracOct ? `${intOct}.${fracOct}` : intOct;
  return {result: trimFracZeros(out), steps};
}

function binToHexWithFrac(raw){
  const {i,f,hasFrac} = splitParts(raw);
  const intPad = padLeftTo(i,4);
  const fracPad = hasFrac ? padRightTo(f,4) : "";
  let steps = LINE("Integer part");
  steps += `Pad to multiple of 4: ${intPad}\nGroup (left): ${(intPad.match(/\d{4}/g)||[]).join(" ")}\n`;
  if(hasFrac){
    steps += LINE("Fractional part");
    steps += `Pad to multiple of 4: ${fracPad}\nGroup (right): ${(fracPad.match(/\d{4}/g)||[]).join(" ")}\n`;
  }
  const intHex = (intPad.match(/\d{4}/g)||[]).map(c=>parseInt(c,2).toString(16).toUpperCase()).join("") || "0";
  const fracHex = hasFrac ? (fracPad.match(/\d{4}/g)||[]).map(c=>parseInt(c,2).toString(16).toUpperCase()).join("") : "";
  const out = fracHex ? `${intHex}.${fracHex}` : intHex;
  return {result: trimFracZeros(out), steps};
}

/* ===== CONVENIENCE WRAPPERS ===== */
function decToBin(raw){ return decToBase(raw, 2); }
function decToOct(raw){ return decToBase(raw, 8); }
function decToHex(raw){ return decToBase(raw,16,"0123456789ABCDEF"); }
function binToDec(raw){ return baseToDec(raw, 2); }
function octToDec(raw){ return baseToDec(raw, 8); }
function hexToDec(raw){ return baseToDec(raw,16); }

/* ===== UI ===== */
function convert(){
  clearOutputs();
  const type = el("conversion").value;
  const raw = el("inputNumber").value.trim();

  if(!raw){
    el("error").textContent = "Please enter a number.";
    el("error").style.display="block";
    return;
  }
  if(!isValid[ expected[type] ](raw)){
    el("error").textContent = "Input does not match the expected base for this conversion (supports an optional fractional part).";
    el("error").style.display="block";
    return;
  }

  let steps = "", result = "";

  switch(type){
    case "decToBin": {
      const {result:r, steps:s} = decToBin(raw);
      result = r; steps = s;
      const {i,f,hasFrac} = splitParts(result);
      const ig = padLeftTo(i,4).match(/\d{4}/g).join(" ");
      steps += LINE("Grouping");
      steps += `Grouped integer (4-bit): ${ig}`;
      if(hasFrac){
        const fg = padRightTo(f,4).match(/\d{4}/g).join(" ");
        steps += `\nGrouped fraction (4-bit): ${fg}`;
      }
      break;
    }
    case "binToDec": {
      const {result:r, steps:s} = binToDec(raw);
      result = r; steps = s;
      const {i,f,hasFrac} = splitParts(raw);
      steps += LINE("Grouping");
      steps += `Binary integer (4-bit): ${padLeftTo(i,4).match(/\d{4}/g).join(" ")}`;
      if(hasFrac){
        const fg = padRightTo(f,4).match(/\d{4}/g).join(" ");
        steps += `\nBinary fraction (4-bit): ${fg}`;
      }
      break;
    }
    case "decToOct": {
      const {result:r, steps:s} = decToOct(raw);
      result = r; steps = s;
      const bin = decToBin(raw).result;
      const {i,f,hasFrac} = splitParts(bin);
      steps += LINE("Binary bridge (3-bit)");
      steps += `int: ${i ? padLeftTo(i,3).match(/\d{3}/g).join(" ") : ""}`;
      if(hasFrac) steps += `\nfrac: ${padRightTo(f,3).match(/\d{3}/g).join(" ")}`;
      break;
    }
    case "octToDec": {
      const {result:r, steps:s} = octToDec(raw);
      result = r; steps = s;
      break;
    }
    case "decToHex": {
      const {result:r, steps:s} = decToHex(raw);
      result = r; steps = s;
      const bin = decToBin(raw).result;
      const {i,f,hasFrac} = splitParts(bin);
      steps += LINE("Binary bridge (4-bit)");
      steps += `int: ${i ? padLeftTo(i,4).match(/\d{4}/g).join(" ") : ""}`;
      if(hasFrac) steps += `\nfrac: ${padRightTo(f,4).match(/\d{4}/g).join(" ")}`;
      break;
    }
    case "hexToDec": {
      const {result:r, steps:s} = hexToDec(raw);
      result = r; steps = s;
      break;
    }
    case "binToOct": {
      const {result:r, steps:s} = binToOctWithFrac(raw);
      result = r; steps = s;
      break;
    }
    case "octToBin": {
      const {bin, steps:s} = octToBinWithFrac(raw);
      steps = s; result = bin;
      break;
    }
    case "binToHex": {
      const {result:r, steps:s} = binToHexWithFrac(raw);
      result = r; steps = s;
      break;
    }
    case "hexToBin": {
      const {bin, steps:s} = hexToBinWithFrac(raw);
      steps = s; result = bin;
      break;
    }
    case "octToHex": {
      const b = octToBinWithFrac(raw);
      const h = binToHexWithFrac(b.bin);
      steps = b.steps + LINE("Binary → Hex") + h.steps;
      result = h.result;
      break;
    }
    case "hexToOct": {
      const b = hexToBinWithFrac(raw);
      const o = binToOctWithFrac(b.bin);
      steps = b.steps + LINE("Binary → Octal") + o.steps;
      result = o.result;
      break;
    }
  }

  show("result", result);
  show("steps", steps);
  show("rule", rules[type]);
}

document.addEventListener("DOMContentLoaded", ()=>{
  document.getElementById("convertBtn").addEventListener("click", convert);
});
</script>
</body>
</html>
